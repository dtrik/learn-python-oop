{
  
    
        "post0": {
            "title": "Python OOP Concepts - Special Methods, Property Decorators",
            "content": "This is based on the wonderful tutorial by Corey Schafer . This notebook is based on the fifth and sixth lecture: . Special Methods . Recall the class we have defined from the last blog: . class Radiant(): num_radiants = 0 first_ideal = &quot;Life before death. Strength before weakness. Journey before destination.&quot; def __init__(self, first_name, last_name): self.first_name = first_name self.last_name = last_name def speak_first_ideal(self): print(f&quot;{self.first_name} has spoken the following ideal: {self.first_ideal}&quot;) self.ideal_count = 1 Radiant.num_radiants += 1 . The above class already contains a special method: the dunder init method. Typically, special methods within a class are used to enable Pythonic behaviour to instances of the class: for eg, to get elements, find length (with a different definition of length) etc. . Consider what happens when we use the len() method on an instance of Radiant. . radiant_1 = Radiant(&quot;Kaladin&quot;, &quot;Stormblessed&quot;) radiant_1.speak_first_ideal() len(radiant_1) . Kaladin has spoken the following ideal: Life before death. Strength before weakness. Journey before destination. . TypeError Traceback (most recent call last) /tmp/ipykernel_11020/2604795060.py in &lt;module&gt; 1 radiant_1 = Radiant(&#34;Kaladin&#34;, &#34;Stormblessed&#34;) 2 radiant_1.speak_first_ideal() -&gt; 3 len(radiant_1) TypeError: object of type &#39;Radiant&#39; has no len() . We can see that the class does not currently support len(). . Let us define a len method that returns the number of ideals spoken by the instance (this is a contrived example): . class Radiant(): num_radiants = 0 first_ideal = &quot;Life before death. Strength before weakness. Journey before destination.&quot; def __init__(self, first_name, last_name): self.first_name = first_name self.last_name = last_name def speak_first_ideal(self): print(f&quot;{self.first_name} has spoken the following ideal: {self.first_ideal}&quot;) self.ideal_count = 1 Radiant.num_radiants += 1 def __len__(self): if hasattr(self, &quot;ideal_count&quot;): return self.ideal_count else: return 0 . radiant_1 = Radiant(&quot;Kaladin&quot;, &quot;Stormblessed&quot;) #radiant_1.speak_first_ideal() print(f&quot;{radiant_1.first_name} has spoken {len(radiant_1)} ideals&quot;) . Kaladin has spoken 0 ideals . We can see that len(radiant_1) is now supported. . Other important uses of special methods are to create dunder repr and dunder str methods. Dunder repr methods are typically used for debugging and indicate how an instance has been created. Dunder str can be used for displaying our instance in a readable manner. In our class, a dunder str method can be used to display the full name of an instance. Let us see how implement both: . class Radiant(): num_radiants = 0 first_ideal = &quot;Life before death. Strength before weakness. Journey before destination.&quot; def __init__(self, first_name, last_name): self.first_name = first_name self.last_name = last_name def speak_first_ideal(self): print(f&quot;{self.first_name} has spoken the following ideal: {self.first_ideal}&quot;) self.ideal_count = 1 Radiant.num_radiants += 1 def __len__(self): if hasattr(self, &quot;ideal_count&quot;): return self.ideal_count else: return 0 def __repr__(self): return f&quot;Radiant({self.first_name}, {self.last_name})&quot; def __str__(self): return f&quot;{self.first_name} {self.last_name}&quot; . radiant_1 = Radiant(&quot;Kaladin&quot;, &quot;Stormblessed&quot;) . print(repr(radiant_1)) . Radiant(Kaladin, Stormblessed) . print(radiant_1) . Kaladin Stormblessed .",
            "url": "https://dtrik.github.io/learn-python-oop/jupyter/2022/08/12/Python_OOP_special_methods_property_decorators.html",
            "relUrl": "/jupyter/2022/08/12/Python_OOP_special_methods_property_decorators.html",
            "date": " • Aug 12, 2022"
        }
        
    
  
    
        ,"post1": {
            "title": "Python OOP Concepts - Inheritance",
            "content": "This is based on the wonderful tutorial by Corey Schafer . This notebook is based on the fourth lecture: . Inheritance . Recall the class (with bells and whistles!) we have defined from the previous blog: . class Radiant(): num_radiants = 0 first_ideal = &quot;Life before death. Strength before weakness. Journey before destination.&quot; def __init__(self, first_name, last_name): self.first_name = first_name self.last_name = last_name def speak_first_ideal(self): print(f&quot;{self.first_name} has spoken the first ideal: {self.first_ideal}&quot;) self.ideal_count = 1 Radiant.num_radiants += 1 def speak_second_ideal(self): if hasattr(self,&quot;ideal_count&quot;): if self.ideal_count == 1: print(f&quot;{self.first_name} has spoken the second ideal: {Windrunner.second_ideal}&quot;) self.ideal_count += 1 else: print(&quot;You have already spoken the second ideal&quot;) else: print(&quot;Speak the first ideal before jumping ahead&quot;) @classmethod def update_ideal(cls, ideal): cls.first_ideal = ideal @classmethod def from_full_name(cls, full_name): first_name, last_name = full_name.split(&#39; &#39;) return cls(first_name, last_name) @staticmethod def swear(curse=&quot;Kelek&#39;s Breath&quot;): print(curse) . Now we want to create further types of Radiant with their own special properties. In such a situation, inheritance becomes useful. This is implemented through the use of Subclasses. Let us see how we can implement two subclasses - Windrunner and Bondsmith of class Radiant: . class Windrunner(Radiant): pass class Bondsmith(Radiant): pass windrunner_1 = Windrunner(&quot;Kaladin&quot;, &quot;Stormblessed&quot;) windrunner_1.speak_first_ideal() bondsmith_1 = Bondsmith(&quot;Dalinar&quot;, &quot;Thorin&quot;) bondsmith_1.speak_first_ideal() . Kaladin has spoken the first ideal: Life before death. Strength before weakness. Journey before destination. Dalinar has spoken the first ideal: Life before death. Strength before weakness. Journey before destination. . We see here that even with an empty subclass, an instance created with it can access all the methods and attributes of the superclass. Let us investigate the namespace of the subclasses and created instances. . print(f&quot;Windrunner class namespace: {Windrunner.__dict__}&quot;) print(f&quot;Bondsmith class namespace: {Bondsmith.__dict__}&quot;) print(f&quot;{windrunner_1.first_name} namespace: {windrunner_1.__dict__}&quot;) print(f&quot;{bondsmith_1.first_name} namespace: {bondsmith_1.__dict__}&quot;) . Windrunner class namespace: {&#39;__module__&#39;: &#39;__main__&#39;, &#39;__doc__&#39;: None} Bondsmith class namespace: {&#39;__module__&#39;: &#39;__main__&#39;, &#39;__doc__&#39;: None} Kaladin namespace: {&#39;first_name&#39;: &#39;Kaladin&#39;, &#39;last_name&#39;: &#39;Stormblessed&#39;, &#39;ideal_count&#39;: 1} Dalinar namespace: {&#39;first_name&#39;: &#39;Dalinar&#39;, &#39;last_name&#39;: &#39;Thorin&#39;, &#39;ideal_count&#39;: 1} . Now let us add some methods and attributes to our Windrunner and Bondsmith classes: . class Windrunner(Radiant): windrunner_count = 0 second_ideal = &quot;I will protect those who cannot protect themselves&quot; def __init__(self, first_name, last_name, squire=None): super().__init__(first_name, last_name) self.squire_count = 0 if squire is None: self.squires = [] else: self.squires = [squire] self.squire_count += 1 Windrunner.windrunner_count += 1 def select_squire(self, name): print(f&quot;{name} is now squiring for {self.first_name}&quot;) self.squires.append(name) self.squire_count += 1 . class Bondsmith(Radiant): bondsmith_count = 0 vision_count = 0 second_ideal = &quot;I will unite instead of divide. I will bring men together.&quot; def __init__(self, first_name, last_name, spren): super().__init__(first_name, last_name) self.spren = spren Bondsmith.bondsmith_count += 1 def undergo_vision(self, vision): print(f&quot;{self.first_name} had a vision of {vision}&quot;) self.vision_count += 1 . Let us now run some methods of the subclass and the superclass. Note that we have created a constructor for the subclass that itself calls the constructor of the superclass. The below two are equivalent in this situation: . super().__init__(first_name, last_name) and Employee.__init__(self,first_name, last_name) . windrunner_1 = Windrunner(&quot;Kaladin&quot;, &quot;Stormblessed&quot;, &quot;Lopen&quot;) windrunner_1.speak_first_ideal() windrunner_1.speak_second_ideal() windrunner_1.select_squire(&quot;Rock&quot;) Windrunner.windrunner_count windrunner_1.squires windrunner_1.squire_count . Kaladin has spoken the first ideal: Life before death. Strength before weakness. Journey before destination. Kaladin has spoken the second ideal: I will protect those who cannot protect themselves Rock is now squiring for Kaladin . 2 . bondsmith_1 = Bondsmith(&quot;Dalinar&quot;, &quot;Thorin&quot;, &quot;Stormfather&quot;) bondsmith_1.speak_first_ideal() bondsmith_1.speak_second_ideal() bondsmith_1.undergo_vision(&quot;Recreance&quot;) . Dalinar has spoken the first ideal: Life before death. Strength before weakness. Journey before destination. Dalinar has spoken the second ideal: I will protect those who cannot protect themselves Dalinar had a vision of Recreance . The help function can be used to further investigate a class. The method resolution order indicates how methods are searched for when they are used. For eg, here first a method is searched in the Windrunner class, then in the super class which is Radiant and finally in the builtins.object from which all classes are derived . print(help(Windrunner)) . Help on class Windrunner in module __main__: class Windrunner(Radiant) | Windrunner(first_name, last_name, squire=None) | | Method resolution order: | Windrunner | Radiant | builtins.object | | Methods defined here: | | __init__(self, first_name, last_name, squire=None) | Initialize self. See help(type(self)) for accurate signature. | | select_squire(self, name) | | - | Data and other attributes defined here: | | second_ideal = &#39;I will protect those who cannot protect themselves&#39; | | windrunner_count = 1 | | - | Methods inherited from Radiant: | | speak_first_ideal(self) | | speak_second_ideal(self) | | - | Class methods inherited from Radiant: | | from_full_name(full_name) from builtins.type | | update_ideal(ideal) from builtins.type | | - | Static methods inherited from Radiant: | | swear(curse=&#34;Kelek&#39;s Breath&#34;) | | - | Data descriptors inherited from Radiant: | | __dict__ | dictionary for instance variables (if defined) | | __weakref__ | list of weak references to the object (if defined) | | - | Data and other attributes inherited from Radiant: | | first_ideal = &#39;Life before death. Strength before weakness. Journey be... | | num_radiants = 4 None . . Two other useful functions are isinstance and issubclass. As the names indicate, they can be used to identify relationships between classes and instances. . print(isinstance(windrunner_1, Bondsmith)) print(isinstance(windrunner_1, Windrunner)) print(issubclass(Bondsmith, Radiant)) print(issubclass(Bondsmith, Windrunner)) . False True True False .",
            "url": "https://dtrik.github.io/learn-python-oop/jupyter/2022/08/11/Python_OOP_inheritance.html",
            "relUrl": "/jupyter/2022/08/11/Python_OOP_inheritance.html",
            "date": " • Aug 11, 2022"
        }
        
    
  
    
        ,"post2": {
            "title": "Python OOP Concepts - Class Variables, Class Methods, Static Methods",
            "content": "This is based on the wonderful tutorial by Corey Schafer . This notebook is based on the second and third lecture: . Class Variables . Recall the class we have defined from the previous blog: . class Radiant(): def __init__(self, first_name, last_name): self.first_name = first_name self.last_name = last_name def speak_first_ideal(self): print(f&quot;{self.first_name} has spoken the following ideal: Life before death. Strength before weakness. Journey before destination.&quot;) self.ideal_count = 1 . Suppose we want to keep track of how many instances of Radiant have been created. This variable would be common across all instances. . class Radiant(): num_radiants = 0 def __init__(self, first_name, last_name): self.first_name = first_name self.last_name = last_name def speak_first_ideal(self): print(f&quot;{self.first_name} has spoken the following ideal: Life before death. Strength before weakness. Journey before destination.&quot;) self.ideal_count = 1 Radiant.num_radiants += 1 . We can see that in the class definition, we have to use Radiant.num_radiants while using the class variable instead of just num_radiants. . Let us see what happens when we create two instances of Radiant. . radiant_1 = Radiant(&quot;Kaladin&quot;, &quot;Stormblessed&quot;) print(Radiant.num_radiants) radiant_1.speak_first_ideal() print(Radiant.num_radiants) radiant_2 = Radiant(&quot;Dalinar&quot;, &quot;Kholin&quot;) print(Radiant.num_radiants) radiant_2.speak_first_ideal() print(Radiant.num_radiants) . 0 Kaladin has spoken the following ideal: Life before death. Strength before weakness. Journey before destination. 1 1 Dalinar has spoken the following ideal: Life before death. Strength before weakness. Journey before destination. 2 . The &#39;num_radiants&#39; class variable is updated each time a radiant speaks the first ideal. This is a variable that should be constant across all the instances of the class. But consider if we want a class level default which can be updated at instance level. For eg: We know that the first ideal is the same across all Radiant Orders. But suppose there is a new instance named Python Zen that wants to speak a different first ideal. Let us see how we can implement that: . class Radiant(): num_radiants = 0 first_ideal = &quot;Life before death. Strength before weakness. Journey before destination.&quot; def __init__(self, first_name, last_name): self.first_name = first_name self.last_name = last_name def speak_first_ideal(self): print(f&quot;{self.first_name} has spoken the following ideal: {self.first_ideal}&quot;) self.ideal_count = 1 Radiant.num_radiants += 1 . radiant_1 = Radiant(&quot;Kaladin&quot;, &quot;Stormblessed&quot;) radiant_2 = Radiant(&quot;Python&quot;, &quot;Zen&quot;) radiant_1.speak_first_ideal() radiant_2.first_ideal = &quot;Beautiful is better than ugly. Explicit is better than implicit. Simple is better than complex.&quot; radiant_2.speak_first_ideal() . Kaladin has spoken the following ideal: Life before death. Strength before weakness. Journey before destination. Python has spoken the following ideal: Beautiful is better than ugly. Explicit is better than implicit. Simple is better than complex. . Here we can see how the first_ideal class variable is used by default when instance specific value is not available. But if we set the first_ideal to a specific value for an instance, within it this new value is used . We can investigate the namespace of the instance and class to further dig into what is happening. The namespace can be seen by printing the __dict__ attribute of a class or instance. . radiant_1 = Radiant(&quot;Kaladin&quot;, &quot;Stormblessed&quot;) radiant_2 = Radiant(&quot;Python&quot;, &quot;Zen&quot;) print(f&quot;Class namespace: {Radiant.__dict__}&quot;) print(f&quot;radiant_1 namespace: {radiant_1.__dict__}&quot;) print(f&quot;radiant_2 namespace: {radiant_2.__dict__}&quot;) . Class namespace: {&#39;__module__&#39;: &#39;__main__&#39;, &#39;num_radiants&#39;: 2, &#39;first_ideal&#39;: &#39;Life before death. Strength before weakness. Journey before destination.&#39;, &#39;__init__&#39;: &lt;function Radiant.__init__&gt;, &#39;speak_first_ideal&#39;: &lt;function Radiant.speak_first_ideal&gt;, &#39;__dict__&#39;: &lt;attribute &#39;__dict__&#39; of &#39;Radiant&#39; objects&gt;, &#39;__weakref__&#39;: &lt;attribute &#39;__weakref__&#39; of &#39;Radiant&#39; objects&gt;, &#39;__doc__&#39;: None} radiant_1 namespace: {&#39;first_name&#39;: &#39;Kaladin&#39;, &#39;last_name&#39;: &#39;Stormblessed&#39;} radiant_2 namespace: {&#39;first_name&#39;: &#39;Python&#39;, &#39;last_name&#39;: &#39;Zen&#39;} . We see that first_ideal is not seen in the namespace of radiant_1 and radiant_2 but the class variable can be accessed by the instance as seen below: . print(f&quot;First ideal of radiant_1 available from the class variable: {radiant_1.first_ideal}&quot;) print(f&quot;First ideal of radiant_2 available from the class variable: {radiant_2.first_ideal}&quot;) . First ideal of radiant_1 available from the class variable: Life before death. Strength before weakness. Journey before destination. First ideal of radiant_2 available from the class variable: Life before death. Strength before weakness. Journey before destination. . radiant_1.speak_first_ideal() radiant_2.first_ideal = &quot;Beautiful is better than ugly. Explicit is better than implicit. Simple is better than complex.&quot; radiant_2.speak_first_ideal() . Kaladin has spoken the following ideal: Life before death. Strength before weakness. Journey before destination. Python has spoken the following ideal: Beautiful is better than ugly. Explicit is better than implicit. Simple is better than complex. . After the speak_first_ideal method is called, let us investigate the namespaces of radiant_1 and radiant_2: . print(f&quot;radiant_1 namespace: {radiant_1.__dict__}&quot;) print(f&quot;radiant_2 namespace: {radiant_2.__dict__}&quot;) . radiant_1 namespace: {&#39;first_name&#39;: &#39;Kaladin&#39;, &#39;last_name&#39;: &#39;Stormblessed&#39;, &#39;ideal_count&#39;: 1} radiant_2 namespace: {&#39;first_name&#39;: &#39;Python&#39;, &#39;last_name&#39;: &#39;Zen&#39;, &#39;first_ideal&#39;: &#39;Beautiful is better than ugly. Explicit is better than implicit. Simple is better than complex.&#39;, &#39;ideal_count&#39;: 1} . We can see that radiant_2 now has a first_ideal variable available to it while radiant_1 does not. radiant_1 still uses the class variable while radiant_2 now has an instance-specific value. When we print the first_ideal variable of the class and the instances, we can see this difference. . print(f&quot;First ideal of class variable: {Radiant.first_ideal}&quot;) print(f&quot;First ideal of radiant_1: {radiant_1.first_ideal}&quot;) print(f&quot;First ideal of radiant_2: {radiant_2.first_ideal}&quot;) . First ideal of class variable: Life before death. Strength before weakness. Journey before destination. First ideal of radiant_1: Life before death. Strength before weakness. Journey before destination. First ideal of radiant_2: Beautiful is better than ugly. Explicit is better than implicit. Simple is better than complex. . Class Methods . Class methods receive the class itself as the input instead of the instance. Suppose from our above example, we want to update the first ideal of the class itself. For this, we need to add a classmethod decorator (@classmethod) above the method definition. Here is how we can do that: . class Radiant(): num_radiants = 0 first_ideal = &quot;Life before death. Strength before weakness. Journey before destination.&quot; def __init__(self, first_name, last_name): self.first_name = first_name self.last_name = last_name def speak_first_ideal(self): print(f&quot;{self.first_name} has spoken the following ideal: {self.first_ideal}&quot;) self.ideal_count = 1 Radiant.num_radiants += 1 @classmethod def update_ideal(cls, ideal): cls.first_ideal = ideal . radiant_1 = Radiant(&quot;Python&quot;, &quot;Zen&quot;) print(f&quot;First ideal of class variable: {Radiant.first_ideal}&quot;) print(f&quot;First ideal of radiant_1: {radiant_1.first_ideal}&quot;) Radiant.update_ideal(&quot;Now is better than never.&quot;) print(f&quot;First ideal of class variable: {Radiant.first_ideal}&quot;) print(f&quot;First ideal of radiant_1: {radiant_1.first_ideal}&quot;) . First ideal of class variable: Life before death. Strength before weakness. Journey before destination. First ideal of radiant_1: Life before death. Strength before weakness. Journey before destination. First ideal of class variable: Now is better than never. First ideal of radiant_1: Now is better than never. . We can see that the class variable and the instance-specific variable has been modified. . Another use-case of class methods is for defining alternative constructors. Suppose instead of passing first_name and second_name separately, the user wants to pass in the full name separated by space. Class methods can be used here to construct our instances and assign the values. Let us see how to do that below: . class Radiant(): num_radiants = 0 first_ideal = &quot;Life before death. Strength before weakness. Journey before destination.&quot; def __init__(self, first_name, last_name): self.first_name = first_name self.last_name = last_name def speak_first_ideal(self): print(f&quot;{self.first_name} has spoken the following ideal: {self.first_ideal}&quot;) self.ideal_count = 1 Radiant.num_radiants += 1 @classmethod def update_ideal(cls, ideal): cls.first_ideal = ideal @classmethod def from_full_name(cls, full_name): first_name, last_name = full_name.split(&#39; &#39;) return cls(first_name, last_name) radiant_1 = Radiant.from_full_name(&quot;Kaladin Stormblessed&quot;) print(radiant_1.first_name) print(radiant_1.last_name) . Kaladin Stormblessed . Adding &quot;from&quot; as a prefix to alternative constructors is a convention. Once we capture the first_name and last_name by splitting the full_name passed into the class method, we call the default constructor and then return the instance that has been created. Note that instead of calling Radiant(first_name, last_name), we are calling cls(first_name, last_name) because Radiant is passed into the class method as cls. . Static Methods . Static methods are basically functions that are part of a class because they are connected to the class. They do not receive the instance or class as default inputs. Suppose we want our Radiant is very frustrated and wants to swear, let us see how to use static methods to do that. Static methods are created by adding a staticmethod decorator (@staticmethod) above the method definition. . class Radiant(): num_radiants = 0 first_ideal = &quot;Life before death. Strength before weakness. Journey before destination.&quot; def __init__(self, first_name, last_name): self.first_name = first_name self.last_name = last_name def speak_first_ideal(self): print(f&quot;{self.first_name} has spoken the following ideal: {self.first_ideal}&quot;) self.ideal_count = 1 Radiant.num_radiants += 1 @classmethod def update_ideal(cls, ideal): cls.first_ideal = ideal @classmethod def from_full_name(cls, full_name): first_name, last_name = full_name.split(&#39; &#39;) return cls(first_name, last_name) @staticmethod def swear(curse=&quot;Kelek&#39;s Breath&quot;): print(curse) Radiant.swear() radiant_1 = Radiant.from_full_name(&quot;Dalinar Thorin&quot;) radiant_1.swear(&quot;Blood of my father&quot;) . Kelek&#39;s Breath Blood of my father . Now that our newly created Radiants from full names can swear different first ideals using classmethods as well as curse using staticmethods, let us stop and look at inheritance in the next blog. .",
            "url": "https://dtrik.github.io/learn-python-oop/jupyter/2022/08/10/Python_OOP_class_variables_methods_static.html",
            "relUrl": "/jupyter/2022/08/10/Python_OOP_class_variables_methods_static.html",
            "date": " • Aug 10, 2022"
        }
        
    
  
    
        ,"post3": {
            "title": "Python OOP Concepts - Classes, Constructors and Methods",
            "content": "This is based on the wonderful tutorial by Corey Schafer . This notebook is based on the first lecture: . Basic Class . Below is the definition of a basic class called Radiant (Go read the Stormlight Archive by Brandon Sanderson if you are fan of fantastic fantasy fiction): . class Radiant(): &quot;An empty class definition&quot; pass radiant_1 = Radiant() radiant_1.first_name = &quot;Kaladin&quot; radiant_1.last_name = &quot;Stormblessed&quot; . Here we have a created an empty class called Radiant. Then we have created an instance of the class Radiant called radiant_1. Finally we have assigned the &#39;first_name&#39; and &#39;last_name&#39; attributes of radiant_1 with the strings &quot;Kaladin&quot; and &quot;Stormblessed&quot; respectively. . print(radiant_1.first_name) print(radiant_1.last_name) . Kaladin Stormblessed . Above, we can see that the &#39;first_name&#39; and &#39;last_name&#39; attributes of radiant_1 are now displayed as expected. Let us now create another instance of radiant called radiant_2 and assign the &#39;first_name&#39; and &#39;last_name&#39; attributes as &quot;Dalinar&quot; and &quot;Thorin&quot;. . radiant_2 = Radiant() radiant_2.first_name = &quot;Dalinar&quot; radiant_2.last_name = &quot;Thorin&quot; . print(radiant_2.first_name) print(radiant_2.last_name) . Dalinar Thorin . This is also working as expected. But we can see that there is a lot of repetition for creating each new instance of the class Radiant. To resolve this, we create a special method inside the Radiant class called a constructor. . Class with Constructor . class Radiant(): &quot;Class with constructor&quot; def __init__(self, first_name, last_name): self.first_name = first_name self.last_name = last_name . The new method above is the constructor for this class. It is also referred to as a &quot;dunder init&quot; method (dunder because the method name is surrounded by double underscores). Whenever a new instance of the Radiant class is created, the constructor is called automatically. The first argument is always &#39;self&#39; and it is a standard terminology that refers to the instance itself. Here we are assigning the instance&#39;s &#39;first_name&#39; and &#39;last_name&#39; based on the 2nd and 3rd arguments passed to it. Once a constructor (__init__) is available, an instance of the class can be created as shown below. . radiant_1 = Radiant(&quot;Kaladin&quot;, &quot;Stormblessed&quot;) print(radiant_1.first_name) print(radiant_1.last_name) . Kaladin Stormblessed . Above, you can see that the same functionality is now available and avoids the repetitive assignment statements. Creating another instance is as simple as: . radiant_2 = Radiant(&quot;Dalinar&quot;, &quot;Kholin&quot;) print(radiant_2.first_name) print(radiant_2.last_name) . Dalinar Kholin . Methods . Now that we have our class Radiant, let us create a function that is specific to this class and something that each instance of the class can use. This type of function is called a method. . Each instance of the class Radiant can speak the first ideal: &quot;Life before death. Strength before weakness. Journey before destination.&quot; Let us create a method in the class to take this ideal. . class Radiant(): &quot;Class with constructor and method&quot; def __init__(self, first_name, last_name): self.first_name = first_name self.last_name = last_name def speak_first_ideal(self): print(f&quot;{self.first_name} has spoken the following ideal: Life before death. Strength before weakness. Journey before destination.&quot;) self.ideal_count = 1 . radiant_1 = Radiant(&quot;Kaladin&quot;, &quot;Stormblessed&quot;) radiant_1.speak_first_ideal() print(f&quot;{radiant_1.first_name} {radiant_1.last_name} has spoken {radiant_1.ideal_count} ideals&quot;) . Kaladin has spoken the following ideal: Life before death. Strength before weakness. Journey before destination. Kaladin Stormblessed has spoken 1 ideals . The above method not only prints the first ideal but also updates a newly created attribute for the instance called &#39;ideal_count&#39;. Inspired by Kaladin, Dalinar is also ready to speak the first ideal . radiant_2 = Radiant(&quot;Dalinar&quot;, &quot;Thorin&quot;) radiant_2.speak_first_ideal() print(f&quot;{radiant_2.first_name} {radiant_2.last_name} has spoken {radiant_2.ideal_count} ideals&quot;) . Dalinar has spoken the following ideal: Life before death. Strength before weakness. Journey before destination. Dalinar Thorin has spoken 1 ideals . The following two are equivalent: . radiant_2.speak_first_ideal() Radiant.speak_first_ideal(radiant_2) . Dalinar has spoken the following ideal: Life before death. Strength before weakness. Journey before destination. Dalinar has spoken the following ideal: Life before death. Strength before weakness. Journey before destination. . Now that both our radiants have taken the first oath, let us continue on this in another page. . All the code is below in a single cell: . class Radiant(): &quot;Class with constructor and method&quot; def __init__(self, first_name, last_name): self.first_name = first_name self.last_name = last_name def speak_first_ideal(self): print(f&quot;{self.first_name} has spoken the following ideal: Life before death. Strength before weakness. Journey before destination.&quot;) self.ideal_count = 1 radiant_1 = Radiant(&quot;Kaladin&quot;, &quot;Stormblessed&quot;) radiant_1.speak_first_ideal() print(f&quot;{radiant_1.first_name} {radiant_1.last_name} has spoken {radiant_1.ideal_count} ideals&quot;) radiant_2 = Radiant(&quot;Dalinar&quot;, &quot;Thorin&quot;) radiant_2.speak_first_ideal() print(f&quot;{radiant_2.first_name} {radiant_2.last_name} has spoken {radiant_2.ideal_count} ideals&quot;) .",
            "url": "https://dtrik.github.io/learn-python-oop/jupyter/2022/08/10/Python_OOP_basics.html",
            "relUrl": "/jupyter/2022/08/10/Python_OOP_basics.html",
            "date": " • Aug 10, 2022"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About",
          "content": "This is a project deployed using fastpages 1 to demonstrate OOP concepts in Python. It is based on the YouTube content by Corey Schafer. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://dtrik.github.io/learn-python-oop/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://dtrik.github.io/learn-python-oop/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}